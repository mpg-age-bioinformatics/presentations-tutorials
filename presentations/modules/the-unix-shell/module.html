<section id="the-unix-shell">
  <h1>The Unix Shell</h1>
  <p><highlight>Welcome to The Unix Shell tutorial.<highlight></p>
  <p>At the end of this tutorial you will be able to move around in a shell, run software, write and run scripts.
    <br>For questions or suggestions  feel free to <a href="mailto:jorge.boucas@age.mpg.de">contact</a> us.</p>
    <br>
    <br>
  <p>
  <small line-height="0.1">
    <font size="3" line-height="0.1">
      <u>References</u>:
      <br>https://github.com/tracykteal/shell-genomics-edamame
      <br>http://www.datacarpentry.org/lessons/#genomics-workshop
      <br>https://software-carpentry.org/lessons/
    </font>
  </small>
</p>
  <aside class="notes" data-markdown>
  This tutorial is followed by the "Help your self on a remote server" tutorial.
  </aside>
</section>

<section id="outline">
  <h1>Outline</h1>
  <font size="6" align="left">
  <div class="column">
    <ul style="padding-left: 40px;">
      <li>What is the shell?
      <br><li>Geeks and repetitive tasks
      <br><li>Resources
      <br><li>How to access the sell
      <br><li>Starting with the shell
      <br><li>Arguments
      <br><li>The Unix directory file structure
      <br><li>Examining the contents of other directories
      <br><li>Shortcut: Tab Completion
      <br><li>Full vs. Relative Paths
      <br><li>Symbolic links
      <br><li>Saving time with wild cards
    </ul>
  </div>
  <div class="column">
    <ul style="padding-left: 100px;">
      <li>Command history
      <br><li>Examining files
      <br><li>Searching files
      <br><li>Redirection
      <br><li>Creating, moving, copying, and removing
      <br><li>Writing files
      <br><li>Running programs
      <br><li>Running scripts
      <br><li>Permissions
      <br><li>Loops
      <br><li>Logical statements
      <br><li>Shell files
      <br><li>Others
    </ul>
  </div>
  </font>
</section>

<section id="theshell">
  <h1>What is the shell?</h1>
  <font size="6" align="left">
    <ul>The shell is a program that presents a command line interface which allows
      you <b>to control your computer using commands entered with a keyboard</b> instead
      of controlling graphical user interfaces (GUIs) with a mouse/keyboard combination.
      <br><br>There are many reasons to learn about the shell.
    </ul>
    <ul style="padding-left: 40px;">
      <br><li><b>For most bioinformatics tools, you have to use the shell.</b> There is no graphical
      interface. If you want to work in metagenomics or genomics you're going to
      need to use the shell.
      <br><br><li>The shell gives you power. The command line gives you the <b>power to do your
      work more efficiently and more quickly</b>.  When you need to do things tens to
       hundreds of times, knowing how to use the shell is transformative.
      <br><br><li><b>To use remote computers or cloud computing, you need to use the shell.</b>
    </ul>
  </font>
</section>

<section id="geeks">
  <h1>Geeks and repetitive tasks</h1>
    <div>
        <img src="modules/the-unix-shell/geeks.png" align="center">
    </div>
</section>

<section id="resources">
  <h1>Resources</h1>
  <font size="5" align="left">
    <ul>
    <b>Shell cheat sheets</b>:
  	<br><a href="http://fosswire.com/post/2007/08/unixlinux-command-cheat-sheet/"
      >&nbsp;&nbsp;&nbsp;&nbsp http://fosswire.com/post/2007/08/unixlinux-command-cheat-sheet/</a>
  	<br><a href="https://files.fosswire.com/2007/08/fwunixref.pdf"
      >&nbsp;&nbsp;&nbsp;&nbsp https://files.fosswire.com/2007/08/fwunixref.pdf</a>
  	<br><a href="https://github.com/swcarpentry/boot-camps/blob/master/shell/shell_cheatsheet.md"
      >&nbsp;&nbsp;&nbsp;&nbsp https://github.com/swcarpentry/boot-camps/blob/master/shell/shell_cheatsheet.md</a>
    <br>
    <br><b>Explain shell - a web site where you can see what the different components of a shell command are doing:</b>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="http://explainshell.com">http://explainshell.com</a>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="http://www.commandlinefu.com">http://www.commandlinefu.com</a>
    <br>
    <br><b>Carpentry:</b>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="https://software-carpentry.org/lessons/">https://software-carpentry.org/lessons/</a>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="http://www.datacarpentry.org/lessons/#genomics-workshop">http://www.datacarpentry.org/lessons/#genomics-workshop</a>
    <br>
    <br><b>Tutorials:</b>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html">http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html</a>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="http://guide.bash.academy">http://guide.bash.academy</a>
    <br>
    <br><b>Interactive learning:</b>
  	<br>&nbsp;&nbsp;&nbsp;&nbsp <a href="https://www.codecademy.com/learn/learn-the-command-line">https://www.codecademy.com/learn/learn-the-command-line</a>
  </ul>
  </font>
</section>

<section id="access">
  <h1>How to access the shell</h1>
  <ul>
    The shell is already available on Mac and Linux.<br>
    For Windows, you'll have to download a separate program.<br>
    <br>
    <b><u>Mac</u></b><br>
    On Mac the shell is available through Terminal<br>
    Applications -> Utilities -> Terminal<br>
    Go ahead and drag the Terminal application to your Dock for easy access.<br>
    <br>
    <b><u>Windows</u></b><br>
    For Windows, we're going to be using gitbash.<br>
    Download and install <a href="http://msysgit.github.io">http://msysgit.github.io</a> on your computer.<br>
    Open up the program.<br>
  <ul>
</section>

<section id="starting">
  <h1>Starting with the shell</h1>
  <font size=6>
    <ul>Enter the following commands:
      <pre><code data-trim>
        git clone https://github.com/mpg-age-bioinformatics/shell-genomics-edamame.git
      </code></pre>
      This command will grab all of the data needed for this workshop from the internet.
      (We're not going to talk about git right now, but it's a tool for doing version control.)
      <pre><code data-trim>
        cd shell-genomics-edamame
      </code></pre>
      `cd` stands for 'change directory'
      <pre><code data-trim>
        ls
      </code></pre>
      `ls` stands for 'list' and it lists the contents of a directory
    </ul>
  </font>
</section>

<section id="starting2">
  <h1>Starting with the shell</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd edamame-data
        ls -F
      </code></pre>
      Anything with a "/" after it is a directory.
      <br>Things with a "*" after them are programs.
      <br>It there's nothing there it's a file.
      <pre><code data-trim>
        ls -l
      </code></pre>
      `ls -l` gives a lot more information too, such as the size of the file:
      <pre><code data-trim>
        &ltfile permissions&gt &ltnumber of links&gt &ltowner&gt &ltgroup&gt &ltsize&gt &ltmonth&gt &ltday&gt &lttime&gt &ltfilename&gt
      </code></pre>
    </ul>
  </font>
</section>

<section id="arguments">
  <h1>Arguments</h1>
  <font size=6>
    <ul>
      Most programs take additional arguments that control their exact
      behavior. For example, `-F` and `-l` are arguments to `ls`.
      <pre><code data-trim>
        man ls
      </code></pre>
      This will open the manual page for `ls`.
      Use the space key to go forward and b to go backwards.
      When you are done reading, just hit `q` to quit.
      <br>Alternative:
      <pre><code data-trim>
        ls --help
      </code></pre>
      Programs that are run from the shell can get extremely complicated.
      To see an example, open up the manual page for the `find` program.
      No one can possibly learn all of these arguments, of course.
      So you will probably find yourself referring back to the manual page frequently.
    </ul>
  </font>
</section>

<section id="structure">
  <h1>The Unix directory file structure</h1>
  <font size=6>
    <ul>
      When we started we first did something like go to the folder of our username.
      Then we opened 'tutorial-shell-genomics' then 'data'.
    </ul>
    <div>
        <img src="modules/the-unix-shell/file_structure.png" align="center">
    </div>
    <ul>
      This is called a hierarchical file system structure, like an upside down
      tree with root (/) at the base that looks like this. That (/) at the base
      is often also called the 'top' level.
      When you are working at your computer or log in to a remote computer,
      you are on one of the branches of that tree, your home directory (/home/username).
    </ul>
  </font>
</section>

<section id="structure2">
  <h1>The Unix directory file structure</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        whoami
      </code></pre>
      This tells you your user name.
      <br>Alternative:
      <pre><code data-trim>
        echo $USER
      </code></pre>
      `USER` is a variable which can be accessed with `$USER` or `${USER}`.
      <pre><code data-trim>
        J=Jorge
        echo ${J}
      </code></pre>
      Spaces â€¦
      <pre><code data-trim>
        J="Jorge Boucas"
        echo ${J}
      </code></pre>
    </ul>
  </font>
</section>

<section id="structure3">
  <h1>The Unix directory file structure</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd
      </code></pre>
      This puts you in your home directory.
      <br>Now using `cd` and `ls`, go in to the 'tutorial-shell-genomics'
      directory and list its contents.
      <br>Let's also check to see where we are. Sometimes when we're wandering around in the file system, it's easy to lose track of where we are and get lost.
      <pre><code data-trim>
        pwd
      </code></pre>
      This stands for 'print working directory'. The directory you're currently working in.
      To go 'back up a level' we need to use `..` ie.
      <pre><code data-trim>
        cd ..
      </code></pre>
    </ul>
  </font>
</section>

<section id="exercise1">
  <h1>Exercise</h1>
  Move around in the 'hidden' directory and try to find the file 'youfoundit.txt'.
</section>

<section id="contents">
  <h1>Examining the contents of other directories</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd
        ls shell-genomics-edamame
      </code></pre>
      This will list the contents of the `edamame-data` directory without you having to navigate there.
      <pre><code data-trim>
        cd
        cd shell-genomics-edamame/edamame-data/hidden
      </code></pre>
        This will make you jump directly to `hidden` without having to go through the intermediate directory.
    </ul>
  </font>
</section>

<section id="exercise2">
  <h1>Exercise</h1>
  Try finding the 'anotherfile.txt' file without changing directories.
</section>

<section id="tab">
  <h1>Shortcut: Tab Completion</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd
        cd s&lttab&gt
      </code></pre>
      The shell will fill in the rest of the directory name for `shell-genomics-edamame`.
      Now go to `shell-genomics-edamame/edamame-data/MiSeq`
      <pre><code data-trim>
        ls F3D&lttab&gt&lttab&gt
      </code></pre>
      When you hit the first tab, nothing happens. The reason is that there are multiple files in the directory which start with `F3D`.
      <br>Tab completion can also fill in the names of programs. For example, enter `e<tab><tab>`. You will see the name of every program that starts with an `e`. One of those is `echo`. If you enter `ec<tab>` you will see that tab completion works.
    </ul>
  </font>
</section>

<section id="paths">
  <h1>Full vs. Relative Paths</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd
        pwd
      </code></pre>
      The output is the full name of your home directory. This tells you that
      you are in a directory called `username`, which sits inside a directory
      called `home` which sits inside the very top directory in the hierarchy.
      The very top of the hierarchy is a directory called `/` which is usually
      referred to as the *root directory*.
      <pre><code data-trim>
        cd /home/&ltusername&gt/shell-genomics-edamame/edamame-data/hidden
      </code></pre>
      This is the full path approach.
      <pre><code data-trim>
        cd
        cd edamame-data/shell/hidden
      </code></pre>
      This is the relative path approach.
    </ul>
  </font>
</section>

<section id="links">
  <h1>Symbolic links</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd
        ln â€“s cd /home/&ltusername&gt/shell-genomics-edamame/edamame-data/hidden hid
      </code></pre>
      This will create a symbolic link called `hid` which will take you to the folder `/home/&ltusername&gt/shell-genomics-edamame/edamame-data/hidden`.
      <br>Check out the content of your home folder:
      <pre><code data-trim>
       ls â€“l ~/
      </code></pre>
      Check out the contents of `hid`:
      <pre><code data-trim>
       ls hid
      </code></pre>
      Remove a symbolic link:
      <pre><code data-trim>
       unlink hid
      </code></pre>
    </ul>
  </font>
</section>

<section id="exercise3">
  <h1>Exercise</h1>
  List the contents of the /bin directory. Do you see anything familiar in there?
</section>

<section id="dataset">
  <h1>Our data set: FASTQ files</h1>
  <ul>
    We did an experiment and want to look at the bacterial communities of <b><u>mice
    in two treatments</u></b> using 16S sequencing. We have <b><u>10 mice in one treatment
    and 9 in another</u></b> treatment. We also sequenced a <b><u>Mock community</u></b>, so we
    can check the quality of our data. So, we have <b><u>20 samples</u></b> all together and
    we've done <b><u>paired-end MiSeq sequencing</u></b>.
    <br>
    <br>We get our data back from the sequencing center as <b><u>FASTQ files</u></b>, and we stick them all in a folder called MiSeq. This data is actually the data we're going to use for several sections of the course, and it's data generated by Pat Schloss.
    <br>
    <br>We want to be able to look at these files and do some things with them.
  </ul>
</section>

<section id="shortcuts">
  <h1>Saving time with shortcuts</h1>
  <font size=6>
    <ul>
      <pre><code data-trim>
        cd; cd shell-genomics-edamame; cd edamame-data
      </code></pre>
      `;` is just another way of doing a line break.
      <br>Now try:
      <pre><code data-trim>
       ls ~
      </code></pre>
      This prints the contents of your home directory, without you having to type the full path.
      <br>The shortcut `..` always refers to the directory above your current directory. Thus:
      <pre><code data-trim>
       ls ..
      </code></pre>
      prints the contents of the `/home/&ltusername&gt/shell-genomics-edamame`. You can chain these together, so:
      <pre><code data-trim>
       ls ../../
      </code></pre>
      prints the contents of `/home/&ltusername&gt` which is your home directory.
    </ul>
  </font>
</section>

<section id="wildcards">
  <h1>Saving time with wild cards</h1>
  <font size=6>
    <ul>
      Navigate to the `~/shell-genomics-edamame/edamame-data/MiSeq` directory.
      <br>
      <br>The `*` character is a shortcut for "everything". Thus, if you enter `ls *`, you will see all of the contents of a given directory. Now try this command:
      <pre><code data-trim>
        ls *fastq
      </code></pre>
      This lists every file that ends with a `fastq`. This command:
      <pre><code data-trim>
        ls /usr/bin/*.sh
      </code></pre>
      lists every file in `/usr/bin` that ends in the characters `.sh`.
      <br>We have paired end sequencing, so for every sample we have two files. If we want to just see the list of the files for the forward direction sequencing we can use:
      <pre><code data-trim>
        ls *R1*fastq
      </code></pre>
      <br>
      What happens if you do `R1*fastq`?
    </ul>
  </font>
</section>

<section id="exercise4">
  <h1>Exercise</h1>
  <font size=6>
    <ol>
      Do each of the following using a single `ls` command without navigating to a different directory.
      <br>
      <br>1. List all of the files in `/bin` that start with the letter 'c'
      <br>2. List all of the files in `/bin` that contain the letter 'a'
      <br>3. List all of the files in `/bin` that end with the letter 'o'
      <br><br>
      BONUS: List all of the files in '/bin' that contain the letter 'a' or 'c'.
    </ol>
  </font>
</section>

<section id="history">
  <h1>Command History</h1>
  <font size=6>
    <ul>
      The <b>up/down arrow</b> takes you backwards/forwards in the command history.
      <br><b>^-C</b> will cancel the command you are writing, and give you a fresh prompt.
      <br><b>^-R</b> will do a reverse-search through your command history.
      <br>You can also review your recent commands with the `history` command:
      <pre><code data-trim>
        history
      </code></pre>
      You can reuse one of these commands directly by referring to the number of that command.
      <br>If your history looked like this:
      <pre><code data-trim>
        259  ls *
        260  ls /usr/bin/*.sh
        261  ls *R1*fastq
      </code></pre>
      then you could repeat command #260 by simply entering:
      <pre><code data-trim>
        !260
      </code></pre>
    </ul>
  </font>
</section>

<section id="exercise5">
  <h1>Exercise</h1>
    Find the line number in your history for the last exercise
    (listing files in /bin) and reissue that command.
</section>

<section id="examining">
  <h1>Examining Files</h1>
    <ul>
      The easiest way to examine a file is to just print out all of the contents using the program `cat`. Enter the following command:
      <pre><code data-trim>
        cat F3D0_S188_L001_R1_001.fastq
      </code></pre>
    </ul>
</section>

<section id="exercise6">
  <h1>Exercise</h1>
  <ul>
    1. Print out the contents of the `~/shell-genomics-edamame/edamame-data/MiSeq/stability.files` file. What does this file contain?
    <br>
    <br>2. Without changing directories, (you should still be in `edamame-data`), use one short command to print the contents of all of the files in the `/home/<username>/shell-genomics-edamame/edamame-data/MiSeq` directory.
  </ul>
</section>

<section id="examining2">
  <h1>Examining Files</h1>
  <font size=6>
    <ul>
      `cat` is a terrific program, but when the file is really big, it can be annoying to use. The program, `less`, is useful for this case. Enter the following command:
      <pre><code data-trim>
      less F3D0_S188_L001_R1_001.fastq
      </code></pre>
      Some commands in `less`:
    </ul>
    <div class="column">
      <ul style="padding-left: 150px;">
        <b>Key</b>
        <br>space
        <br>b
        <br>g
        <br>G
        <br>1
      </ul>
    </div>

    <div class="column">
      <ul style="padding-left: 0px;">
        <b>Action</b>
        <br>to go forward
        <br>to go backward
        <br>to go to the beginning
        <br>to go to the end
        <br>to quit
      </ul>
    </div>
    <ul>
      `less` also gives you a way of searching through files. Just hit the "/" key to begin a search. Enter the name of the word you would like to search for and hit enter. It will jump to the next location where that word is found. Try searching the `dictionary.txt` file for the word "cat".
    </ul>
  </font>
</section>

<section id="examining3">
  <h1>Examining Files</h1>
  <font size=6>
    <ul>
      If you hit "/" then "enter", `less` will just repeat the previous search.
      <b>`less` searches from the current location and works its way forward</b>. If
      you are at the end of the file and search for the word "cat", `less` will
      not find it. You need to go to the beginning of the file and search.
      <br>
      <br>For instance, let's search for the sequence `1101:14341` in our file.
      <br>
      <br>You can see that we go right to that sequence and can see what it looks like.
      <br>
      <br>Remember, the `man` program actually uses `less` internally and therefore
      uses the same commands, so you can search documentation using "/" as well!
    </ul>
  </font>
</section>

<section id="examining4">
  <h1>Examining Files</h1>
  <font size=6>
    <ul>
      The commands are `head` and `tail` and they just let you look at the
      beginning and end of a file respectively.
      <pre><code data-trim>
        head F3D0_Shead F3D0_S188_L001_R1_001.fastq
        tail F3D0_S188_L001_R1_001.fastq188_L001_R1_001.fastq
      </code></pre>
      The `-n` option to either of these commands can be used to print the
      first or last `n` lines of a file. To print the first/last line of the
      file use:
      <pre><code data-trim>
         head â€“n 1 F3D0_Shead F3D0_S188_L001_R1_001.fastq
         tail â€“n 1 F3D0_S188_L001_R1_001.fastq188_L001_R1_001.fastq
      </code></pre>
    </ul>
  </font>
</section>

<section id="searching">
  <h1>Searching files</h1>
  <font size=6>
    <ul>
      `grep` is a command-line utility for searching plain-text data sets for
      lines matching a string or regular expression.
      <br>
      <br>Let's search for that sequence 1101:14341 in the F3D0_S188_L001_R1_001.fastq file.
      <pre><code data-trim>
        grep 1101:14341 F3D0_S188_L001_R1_001.fastq
      </code></pre>
      What if we wanted all four lines, the whole part of that FASTQ sequence, back instead.
      <pre><code data-trim>
        grep -A 3 1101:14341 F3D0_S188_L001_R1_001.fastq
      </code></pre>
      The `-A` flag stands for "after match" so it's returning the line that
      matches plus the three after it.
      The `-B` flag returns that number of lines before the match.
    </ul>
  </font>
</section>

<section id="exercise7">
  <h1>Exercise</h1>
  <ul>
    Search for the sequence 'TTATCCGGATTTATTGGGTTTAAAGGGT' in the
    F3D0_S188_L001_R1_001.fastq file and in the output have the sequence name
    and the sequence. e.g.
    <br>
    <br>@M00967:43:000000000-A3JHG:1:2114:11799:28499 1:N:0:188
    <br>TACGGAGGATGCGAGCGTTATCCGGATTTATTGGGTTTAAAGGGTGCGTAGGC
    <br>
    <br>Search for that sequence in all the FASTQ files.
  </ul>
</section>

<section id="redirection1">
  <h1>Redirection</h1>
  <font size=6>
    <ul>
      All those sequences just went whizzing by with grep. How can we capture them?
      <br>The redirection command for putting something in a file is `>`
      <pre><code data-trim>
        grep -B 2 TTATCCGGATTTATTGGGTTTAAAGGGT * > good-data.txt
        ls
      </code></pre>
      `>>` does the same as `>` but appending the ouput to file in case it already exists.
    </ul>
  </font>
</section>

<section id="redirection2">
  <h1>Redirection</h1>
  <font size=6>
    <ul>
      The `|` takes the output that scrolling by on the terminal and then can
      run it through another command.
      <pre><code data-trim>
        grep TTATCCGGATTTATTGGGTTTAAAGGGT * | less
      </code></pre>
      Now we can use the arrows to scroll up and down and use `q` to get out.
      <br>
      <br>`wc` stands for `word count`. It counts the number of lines or characters.
      <pre><code data-trim>
        grep TTATCCGGATTTATTGGGTTTAAAGGGT * | wc
      </code></pre>
      That tells us the number of lines, words and characters in the file.
      If we just want the number of lines, we can use the `-l` flag for `lines`.
      <pre><code data-trim>
        grep TTATCCGGATTTATTGGGTTTAAAGGGT * | wc â€“l
      </code></pre>
    </ul>
  </font>
</section>

<section id="create">
  <h1>Creating, moving, copying, and removing</h1>
  <font size=6>
    <ul>
      Navigate to the `data` directory. Lets copy the file using the `cp` command.
      <pre><code data-trim>
        cp stability.files stability.files_backup
      </code></pre>
      The `mkdir` command is used to make a directory.
      <pre><code data-trim>
       mkdir backup
      </code></pre>
      We can move files around using the command `mv`.
      <pre><code data-trim>
       mv stability.files_backup backup/
      </code></pre>
      This moves `stability.files_backup` into the directory `backup/` or the full path would be `~/edamame-data/shell/MiSeq/backup`
    </ul>
  </font>
</section>

<section id="create2">
  <h1>Creating, moving, copying, and removing</h1>
  <font size=6>
    <ul>
      The `mv` command is also how you rename files.
      <pre><code data-trim>
        mv stability.files stability.files_IMPORTANT
      </code></pre>
      The `rm` file removes the file. Be careful with this command. It doesn't
      just nicely put the files in the Trash. They're really gone.
      <pre><code data-trim>
        rm backup/stability.files_backup
      </code></pre>
      By default, `rm`, will NOT delete directories. You can tell `rm` to delete a directory using the `-r` option. Let's delete that `new` directory we just made. Enter the following command:
      <pre><code data-trim>
        rm -r new
      </code></pre>
    </ul>
  </font>
</section>

<section id="exercise8">
  <h1>Exercise</h1>
  <ul>
    Do the following:
    <br>
    <br>1.  Rename the `stability.files_IMPORTANT` file to `stability.files`.
    <br>2.  Create a directory in the `MiSeq` directory called `new`
    <br>3.  Then, copy the `stability.files` file into `new`
  </ul>
</section>

<section id="write">
  <h1>Writing files</h1>
  <font size=6>
    <ul>
      To write in files, we're going to use the program `nano`. We're going to
      create a file that contains the favorite grep command so you can remember
      it for later. We'll name this file 'awesome.shâ€™.
      <pre><code data-trim>
        nano awesome.sh
      </code></pre>
      </ul>
      <div>
          <img src="modules/the-unix-shell/nano.png" align="center">
      </div>
      <ul>
      Type `Ctrl-X`. It will ask if you want to save it. Type `y` for yes.
      Then it asks if you want that file name. Hit 'Enter'.
    </ul>
  </font>
</section>

<section id="exercise9">
  <h1>Exercise</h1>
  <ul>
    <br>Open 'awesome.sh' and add "echo AWESOME!" after the grep command and save the file.
    <br>
    <br>We're going to come back and use this file in just a bit.
  </ul>
</section>

<section id="programs">
  <h1>Running programs</h1>
  <font size=6>
    <ul>
      Commands like `ls`, `rm`, `echo`, and `cd` are just ordinary programs on the computer. A program is just a file that you can *execute*. The program `which` tells you the location of a particular program. For example:
      <pre><code data-trim>
        which ls
        which find
      </code></pre>
      <br>
      When we enter a program name and hit enter, there are a few standard places that the shell automatically looks. Enter the command:
      <pre><code data-trim>
        echo $PATH
      </code></pre>
    </ul>
  </font>
</section>

<section id="programs2">
  <h1>Running programs</h1>
  <font size=6>
    <ul>
      Navigate to the `edamame-data` directory and list the contents. Try to run the program `hello.sh` by entering:
      <pre><code data-trim>
        hello.sh
      </code></pre>
      <br>
      You should get an error saying that hello.sh cannot be found. That is
      because the directory `/home/username/edamame-data/shell` is not in the
      `PATH`. You can run the `hello.sh` program by entering:
      <pre><code data-trim>
        ./hello.sh
      </code></pre>
      Remember that `.` is a shortcut for the current working directory. You can
      run `hello.sh` equally well by specifying one of the following options:
      <pre><code data-trim>
         /home/&ltusername&gt/shell-genomics-edamame/edamame-data/hello.sh
         ~/shell-genomics-edamame/edamame-data/hello.sh
      </code></pre>
    </ul>
  </font>
</section>

<section id="scritps1">
  <h1>Running scripts</h1>
  <font size=6>
    <ul>
      Go in to the 'MiSeq' directory where we created 'awesome.sh' before.
      It's a command, so we should just be able to run it. Give it a try.
      <pre><code data-trim>
        ./awesome.sh
      </code></pre>
      To do that we have to make it 'executable'. We do this by changing its
      mode. The command for that is `chmod` - change mode. We're going to change
      the mode of this file, so that it's executable and the computer knows it's
      OK to run it as a program.
      <pre><code data-trim>
        chmod +x awesome.sh
      </code></pre>
      Try running it again:
      <pre><code data-trim>
        ./awesome.sh
      </code></pre>
      Alternative, change permissions while changing mode:
      <pre><code data-trim>
        chmod 755 awesome.sh ; ./awesome.sh
      </code></pre>
    </ul>
  </font>
</section>

<section id="permissions">
  <h1>Permissions</h1>
  <font size=6>
    <ul>
    <div>
        <img src="modules/the-unix-shell/permissions.png" width="400" align="center">
    </div>
  </ul>
</font>
</section>

<section id="loops">
  <h1>Loops</h1>
  <font size=6>
    <ul>
      Syntax:
      <pre><code data-trim>
        for &ltvariable&gt in &ltvariables&gt ;
            do
            echo ${&ltvariable&gt}
        done
      </code></pre>
      Example:
      <pre><code data-trim>
        for name in jorge franziska rafael daniel ;
            do
            echo ${name}
        done
      </code></pre>
      Alternative:
      <pre><code data-trim>
        items_variable="jorge franziska rafael daniel"
        for item in ${items_variable} ;
            do
            echo ${item}
        done
      </code></pre>
  </ul>
</font>
</section>

<section id="loops2">
  <h1>Loops</h1>
  <font size=6>
    <ul>
      Syntax:
      <pre><code data-trim>
        while &ltcondition TRUE&gt ;
            do
            &ltsomething&gt
        done
      </code></pre>
      Example:
      <pre><code data-trim>
        while read line ;
            do
            echo ${line}
        done < file.txt
      </code></pre>
    </ul>
  </font>
</section>

<section id="ifs">
  <h1>IF statements</h1>
  <font size=6>
    <ul>
      Syntax:
      <pre><code data-trim>
        if [ &ltcondition TRUE&gt ] ;
            then
              &ltsomething&gt
            else;
            &ltsomething else&gt
            fi
      </code></pre>
      Example:
      <pre><code data-trim>
        J=Jorge
        if [ ${J} == "Jorge" ] ;
            then
            echo ${J}
        else;
            echo "This is not Jorge"
        fi
      </code></pre>
    </ul>
  </font>
</section>

<section id="files">
  <h1>Shell files</h1>
  <font size=6>
    <ul>
      From `man bash`:
      <pre><code data-trim>
        /bin/bash
               The bash executable
        /etc/profile
               The systemwide initialization file, executed for login shells
        ~/.bash_profile
               The personal initialization file, executed for login shells
        ~/.bashrc
               The individual per-interactive-shell startup file
        ~/.bash_logout
               The individual login shell cleanup file, executed when a login shell exits
        ~/.inputrc
               Individual readline initialization file
      </code></pre>
      Example `~/.bash_profile`
      <pre><code data-trim>
        export LC_ALL=en_US.UTF-8
        export LANG=en_US.UTF-8
        export PATH=~/soft/bin:$PATH
        source /software/Modules/modules.rc
        export PS1="\[\033[01;32m\]\h\[\033[00m\]:\[\033[01;34m\]\$CurDir\$\[\033[00m\] "
      </code></pre>
    </ul>
  </font>
</section>

<section id="others">
  <h1>Others</h1>
  <font size=6>
    <ul>
      Disk usage of a folder. Example, your home folder:
      <pre><code data-trim>
        cd ~ ; du â€“sh .
      </code></pre>
      Connecting to a remote server over a Secure Shell (ssh) â€“ ssh username@remote.adress :
      <pre><code data-trim>
        ssh JBoucas@amalia.age.mpg.de
      </code></pre>
      Copying files over ssh to your home folder on a remote server:
      <pre><code data-trim>
        scp file.txt UName@ServerAddress:~/
      </code></pre>
      Copying files over ssh from your home folder on a remoter server:
      <pre><code data-trim>
        scp UName@ServerAddress:~/file.txt .
      </code></pre>
      Both `scp` will only allow you to copy files (not directories) unless you
      use the `-r` argument for `recursively`.
    </ul>
  </font>
</section>

<section id="end">
  <h1>END</h1>
  <font size=6>
      <br>
      <br>
      <br><a href="mailto:jorge.boucas@age.mpg.de">jorge.boucas@age.mpg.de</a>
      <br><br><a href="mailto:bioinformatics@age.mpg.de">bioinformatics@age.mpg.de</a>
      <br><br><a href="https://mpg-age-bioinformatics.github.io">https://mpg-age-bioinformatics.github.io</a>
  </font>
</section>
